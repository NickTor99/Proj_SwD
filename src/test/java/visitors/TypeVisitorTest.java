package visitors;

import exceptions.TypeMismatchException;
import exceptions.UndeclaredVariableException;
import autogenerated.sym;
import nodes.*;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import table.SymbolRecord;
import table.SymbolTable;

import java.util.ArrayList;
import java.util.Stack;

import static org.junit.jupiter.api.Assertions.*;

class TypeVisitorTest {

    TypeVisitor typeVisitor;
    SymbolTable symbolTable;

    public TypeVisitorTest(){

    }

    @BeforeEach
    void setUp() {
        typeVisitor = new TypeVisitor();
        symbolTable = new SymbolTable("testScope");
        symbolTable.put("v1",new SymbolRecord("v1","var",sym.REAL));
        symbolTable.put("v2",new SymbolRecord("v2","var",sym.REAL));
        ArrayList<Integer> parType = new ArrayList<>();
        ArrayList<Boolean> paramsOut = new ArrayList<>();
        parType.add(sym.INTEGER);parType.add(sym.STRING);
        paramsOut.add(false);paramsOut.add(true);
        symbolTable.put("notVoidFun",new SymbolRecord("notVoidFun","fun",parType,paramsOut,sym.INTEGER));
        symbolTable.put("returnFun",new SymbolRecord("returnFun","fun",null,null,sym.INTEGER));
        symbolTable.put("voidFun",new SymbolRecord("voidFun","fun",null,null,sym.VOID));
        symbolTable.put("outPar",new SymbolRecord("outPAr","par",sym.STRING,true));

        Stack<SymbolTable> scope = new Stack<>();
        scope.push(symbolTable);
        typeVisitor.setActiveStackScope(scope);
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    void visitBiExprNode() {
        BiExprNode plus = new BiExprNode("PLUS",new ConstExprNode("INTEGER_CONST","10"),new ConstExprNode("INTEGER_CONST","10"));
        BiExprNode pow = new BiExprNode("POW",new ConstExprNode("INTEGER_CONST","10"),new ConstExprNode("INTEGER_CONST","10"));
        BiExprNode and = new BiExprNode("AND",new ConstExprNode("BOOL","true"),new ConstExprNode("BOOL","false"));
        BiExprNode eq = new BiExprNode("EQ",new ConstExprNode("INTEGER_CONST","10"),new ConstExprNode("INTEGER_CONST","10"));
        BiExprNode concat = new BiExprNode("STR_CONCAT",new ConstExprNode("STRING_CONST","ciao"),new ConstExprNode(" a tutti","10"));
        BiExprNode div = new BiExprNode("DIV",new ConstExprNode("INTEGER_CONST","10"),new ConstExprNode("INTEGER_CONST","10"));

        typeVisitor.visit(plus);
        typeVisitor.visit(pow);
        typeVisitor.visit(and);
        typeVisitor.visit(eq);
        typeVisitor.visit(concat);
        typeVisitor.visit(div);

        assertEquals(sym.INTEGER,plus.getType());
        assertEquals(sym.REAL,pow.getType());
        assertEquals(sym.BOOL,and.getType());
        assertEquals(sym.BOOL,eq.getType());
        assertEquals(sym.STRING,concat.getType());
        assertEquals(sym.REAL,div.getType());
    }

    @Test
    void visitUnExprNode() {
        UnExprNode minus = new UnExprNode("MINUS",new ConstExprNode("REAL_CONST","5.4"));
        UnExprNode not = new UnExprNode("NOT",new ConstExprNode("BOOL","true"));

        typeVisitor.visit(minus);
        typeVisitor.visit(not);

        assertEquals(sym.REAL,minus.getType());
        assertEquals(sym.BOOL,not.getType());
    }

    @Test
    void visitIdExprNode() {
        IdExprNode id = new IdExprNode("ID","v1");
        typeVisitor.visit(id);
        assertEquals(sym.REAL,id.getType());

        IdExprNode id2 = new IdExprNode("ID","nonesiste");
        assertThrows(UndeclaredVariableException.class,() -> typeVisitor.visit(id2));
    }

    @Test
    void visitAssignOp() {
        // assign with 1 expr
        ArrayList<IdInit> idList = new ArrayList<>();
        ArrayList<ExprNode> exprList = new ArrayList<>();
        idList.add(new IdInit(new IdExprNode("ID","v1"),null,null));
        idList.add(new IdInit(new IdExprNode("ID","v2"),null,null));
        exprList.add(new ConstExprNode("INTEGER_CONST","10"));
        AssignOp assign = new AssignOp("ASSIGN",idList,exprList);
        typeVisitor.visit(assign);
        assertEquals(sym.VOID,assign.getType());

        // assign with #id = #expr
        exprList.add(new ConstExprNode("REAL_CONST","6.66"));
        AssignOp assign2 = new AssignOp("ASSIGN",idList,exprList);
        typeVisitor.visit(assign2);
        assertEquals(sym.VOID,assign2.getType());

        // assign with #id != #expr
        exprList.add(new ConstExprNode("REAL_CONST","9.99"));
        AssignOp assign3 = new AssignOp("ASSIGN",idList,exprList);
        assertThrows(Error.class,() -> typeVisitor.visit(assign3));
    }

    @Test
    void visitProgramOp() {
        SymbolTable table = new SymbolTable("test");
        table.put("var1",new SymbolRecord("var1","var",sym.INTEGER));
        ArrayList<AbstractSyntaxNode> emptyList = new ArrayList<>();
        ArrayList<VarDeclOp> varList = new ArrayList<>();
        ArrayList<IdInit> idList = new ArrayList<>();
        idList.add(new IdInit(new IdExprNode("ID","var1"),null,null));
        varList.add(new VarDeclOp("STRING",idList));
        FunOp fun = new FunOp(new IdExprNode("ID","test"),new ArrayList<>(),"VOID",new BodyOp(varList,null));
        ProgramOp programOp = new ProgramOp(
                emptyList,
                new IsMainFunOp(true,fun),
                emptyList
        );
        fun.setSymbolTable(table);
        typeVisitor.visit(programOp);

        assertEquals(sym.VOID,programOp.getType());
    }

    @Test
    void visitVarDeclOp() {
        ArrayList<IdInit> idList = new ArrayList<>();
        ArrayList<IdInit> idList2 = new ArrayList<>();
        IdInit v1 = new IdInit(new IdExprNode("ID","v1"),null,new ConstExprNode("INTEGER_CONST","100"));
        IdInit v2 = new IdInit(new IdExprNode("ID","v2"),new ConstExprNode("INTEGER_CONST","100"),null);
        idList.add(v1);
        idList2.add(v2);
        VarDeclOp varDecl1 = new VarDeclOp("VAR",idList);
        VarDeclOp varDecl2 = new VarDeclOp("INTEGER",idList2);
        typeVisitor.visit(varDecl1);
        typeVisitor.visit(varDecl2);

    }

    @Test
    void visitFunOp() {
        //testing not void function without return statment
        SymbolTable funTable = new SymbolTable("FUN","notVoidFun");
        funTable.put("param",new SymbolRecord("param","param",sym.INTEGER));
        funTable.put("outPar",new SymbolRecord("outPar","param",sym.STRING,true));
        ArrayList<ParDeclOp>parList = new ArrayList<>();
        parList.add(new ParDeclOp("IN","INTEGER",new IdInit(new IdExprNode("ID","param"),null,null)));
        parList.add(new ParDeclOp("OUT","STRING",new IdInit(new IdExprNode("ID","outPar"),null,null)));
        ArrayList<StatOp> statList = new ArrayList<>();
        FunOp notVoidFun = new FunOp(
                new IdExprNode("ID","notVoidFun"),
                parList,
                "INTEGER",
                new BodyOp(new ArrayList<>(),statList));
        notVoidFun.setSymbolTable(funTable);
        assertThrows(Error.class,() -> typeVisitor.visit(new IsMainFunOp(true,notVoidFun)));

        // with the return statment works
        statList.add(new ReturnStatOp("RETURN",new IdExprNode("ID","param")));
        typeVisitor.visit(new IsMainFunOp(true,notVoidFun));

        //testing void function with return statment
        statList.clear();
        statList.add(new ReturnStatOp("RETURN",new IdExprNode("ID","return")));
        SymbolTable funTable2 = new SymbolTable("FUN","voidFun");
        funTable2.put("return",new SymbolRecord("return","var",sym.VOID));
        FunOp voidFun = new FunOp(new IdExprNode("ID","voidFun"), null, "VOID", new BodyOp(new ArrayList<>(),statList));
        voidFun.setSymbolTable(funTable2);
        assertThrows(Error.class,() -> typeVisitor.visit(new IsMainFunOp(false,voidFun)));

        //without the return statment works
        typeVisitor.setHasReturn(false);
        statList.clear();
        typeVisitor.visit(new IsMainFunOp(false,voidFun));
    }

    @Test
    void visitCallFunOp() {
        // good function call
        ArrayList<CallParamOp> callParams = new ArrayList<>();
        callParams.add(new CallParamOp(new IdExprNode("ID","outPar"),true));
        callParams.add(new CallParamOp(new ConstExprNode("INTEGER_CONST","10"),false));
        CallFunOp callFun = new CallFunOp("CALLFUN",new IdExprNode("ID","notVoidFun"),callParams);
        typeVisitor.visit(callFun);
        assertEquals(sym.INTEGER,callFun.getType());
        assertEquals(sym.INTEGER,callFun.getId().getType());

        // wrong type parameter function call
        callParams.clear();
        callParams.add(new CallParamOp(new IdExprNode("ID","outPar"),false));
        callParams.add(new CallParamOp(new ConstExprNode("STRING_CONST","10"),false));
        CallFunOp wrongTypeCallFun = new CallFunOp("CALLFUN",new IdExprNode("ID","notVoidFun"),callParams);
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongTypeCallFun));

        //wrong number of parameter function call
        callParams.clear();
        callParams.add(new CallParamOp(new IdExprNode("ID","outPar"),true));
        callParams.add(new CallParamOp(new ConstExprNode("INTEGER_CONST","10"),false));
        callParams.add(new CallParamOp(new ConstExprNode("STRING_CONST","10"),false));
        CallFunOp wrongNumCallFun = new CallFunOp("CALLFUN",new IdExprNode("ID","notVoidFun"),callParams);
        assertThrows(Error.class,() -> typeVisitor.visit(wrongNumCallFun));

        //wrong out parameter function call
        callParams.clear();
        callParams.add(new CallParamOp(new ConstExprNode("STRING_CONST","10"),false));
        callParams.add(new CallParamOp(new ConstExprNode("INTEGER_CONST","10"),false));
        CallFunOp wrongOutParCallFun = new CallFunOp("CALLFUN",new IdExprNode("ID","notVoidFun"),callParams);
        assertThrows(Error.class,() -> typeVisitor.visit(wrongOutParCallFun));

    }

    @Test
    void visitReturnStatOp() {
        // right return statement
        SymbolTable funTable = new SymbolTable("FUN","returnFun");
        funTable.put("var1",new SymbolRecord("var1","var",sym.INTEGER));
        SymbolTable ifTable = new SymbolTable("IF");
        typeVisitor.getActiveStackScope().push(funTable);
        typeVisitor.getActiveStackScope().push(ifTable);
        ReturnStatOp rtrn = new ReturnStatOp("RETURN",new IdExprNode("ID","var1"));
        typeVisitor.visit(rtrn);
        assertEquals(sym.VOID,rtrn.getType());

        typeVisitor.getActiveStackScope().pop();
        typeVisitor.getActiveStackScope().pop();

        // variable and function name conflict
        SymbolTable wrongFunTable = new SymbolTable("FUN","v1");
        typeVisitor.getActiveStackScope().push(wrongFunTable);
        assertThrows(Error.class,() -> typeVisitor.visit(rtrn));

        // missing function for the return statement
        typeVisitor.getActiveStackScope().pop();
        typeVisitor.getActiveStackScope().push(ifTable);
        assertThrows(Error.class,() -> typeVisitor.visit(rtrn));

        typeVisitor.getActiveStackScope().pop();

        // type mismatch between return type and function type
        funTable.put("var2",new SymbolRecord("var2","var",sym.CHAR));
        ReturnStatOp wrongRtrn = new ReturnStatOp("RETURN",new IdExprNode("ID","var2"));
        typeVisitor.getActiveStackScope().push(funTable);
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongRtrn));
    }

    @Test
    void visitIfStatOp() {
        ConstExprNode condition = new ConstExprNode("BOOL","true");
        BodyOp body = new BodyOp(new ArrayList<>(),new ArrayList<>());
        IfStatOp ifStat = new IfStatOp("IF",condition,body,body);
        typeVisitor.visit(ifStat);
        assertEquals(sym.VOID,ifStat.getType());

        ConstExprNode wrongCondition = new ConstExprNode("STRING_CONST","true");
        IfStatOp wrongIfStat = new IfStatOp("IF",wrongCondition,body,null);
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongIfStat));
    }

    @Test
    void visitWhileOp() {
        ConstExprNode condition = new ConstExprNode("BOOL","true");
        BodyOp body = new BodyOp(new ArrayList<>(),new ArrayList<>());
        WhileOp whileStat = new WhileOp("WHILE",condition,body);
        typeVisitor.visit(whileStat);
        assertEquals(sym.VOID,whileStat.getType());

        ConstExprNode wrongCondition = new ConstExprNode("STRING_CONST","true");
        WhileOp wrongWhileStat = new WhileOp("WHILE",wrongCondition,body);
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongWhileStat));
    }

    @Test
    void visitForStatOp() {
        SymbolTable forTable = new SymbolTable("FOR");
        forTable.put("i",new SymbolRecord("i","var",sym.INTEGER));
        IdExprNode index = new IdExprNode("ID","i");
        ConstExprNode const1 = new ConstExprNode("INTEGER_CONST","0");
        ConstExprNode const2 = new ConstExprNode("INTEGER_CONST","5");
        BodyOp body = new BodyOp(new ArrayList<>(),new ArrayList<>());
        ForStatOp forStat = new ForStatOp("FOR",index,const1,const2,body);
        forStat.setSymbolTable(forTable);
        typeVisitor.visit(forStat);
        assertEquals(sym.VOID,forStat.getType());

        ConstExprNode const3 = new ConstExprNode("STRING_CONST","0");
        ConstExprNode const4 = new ConstExprNode("REAL_CONST","5");
        ForStatOp wrongFor1 = new ForStatOp("FOR",index,const1,const4,body);
        ForStatOp wrongFor2 = new ForStatOp("FOR",index,const3,const1,body);
        ForStatOp wrongFor3 = new ForStatOp("FOR",index,const3,const4,body);
        wrongFor1.setSymbolTable(forTable);
        wrongFor2.setSymbolTable(forTable);
        wrongFor3.setSymbolTable(forTable);
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongFor1));
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongFor2));
        assertThrows(TypeMismatchException.class,() -> typeVisitor.visit(wrongFor3));
    }

    @Test
    void visitReadOp() {
        ArrayList<IdInit> idList = new ArrayList<>();
        idList.add(new IdInit(new IdExprNode("ID","v1"),null,null));
        idList.add(new IdInit(new IdExprNode("ID","v2"),null,null));
        ReadOp readOp = new ReadOp("READ",idList,new ConstExprNode("STRING_CONST","ciao"));
        typeVisitor.visit(readOp);
        assertEquals(sym.VOID,readOp.getType());
    }

    @Test
    void visitWriteOp() {
        ArrayList<ExprNode> exprList = new ArrayList<>();
        exprList.add(new IdExprNode("ID","v1"));
        WriteOp writeOp = new WriteOp("WRITE","WRITELN",exprList);
        typeVisitor.visit(writeOp);
        assertEquals(sym.VOID,writeOp.getType());
    }
}